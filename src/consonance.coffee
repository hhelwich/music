# Imports / Aliases
pow = Math.pow

# The hearing range of the human ear [Hz]
# see: http://en.wikipedia.org/wiki/Hearing_range
#
# hearingRange :: [number]
hearingRange = [20, 20000]

# Returns `true` if the given frequency is in the hearing range of the human ear.
#
# audible :: number -> boolean
audible = (f) ->
  hearingRange[0] <= f <= hearingRange[1]

# see: http://de.wikipedia.org/wiki/Frequenzgruppe
bandFreq = [
  100, 200, 300, 400, 510, 630, 770, 920, 1080, 1270, 1480, 1720, 2000
  2320, 2700, 3150, 3700, 4400, 5300, 6400, 7700, 9500, 12000, 15500
]

# Returns an approximation for the bandwidth [Hz] for a given frequency [Hz].
# The function parameters are generated by a polynom interpolation with octave by the band informations found on
# wikipedia (see above).
# Input should be in the range [20...20000] to return meaningful values.
#
# bandWidth :: number -> number
bandWidth = (f) ->
  2.16744546124192e-21 * (pow f, 6) - 1.14331395137110e-16 * (pow f, 5) +
  2.21019714132913e-12 * (pow f, 4) - 1.96581284278883e-08 * (pow f, 3) +
  9.17364358141604e-05 * (pow f, 2) - 2.19151327511146e-02 * f + 1.04461844370372e+02

# First try of a metric to give the friction for two frequencies.
#
# friction :: number -> number -> number(0…1)
friction = (f, g) ->
  if (not audible f) or not audible g
    0 # If at least one frequency is out of the hearing range => maximal one frequency is audible => no friction
  else
    halfWidth = (bandWidth (f + g) / 2) / 2
    dist = Math.abs f - g
    if halfWidth <= dist
      0 # Both frequencies are in the hearing range but too far away from each other to cause friction
    else
      # Sinus a usable approximation for the friction?
      Math.sin dist / halfWidth * Math.PI

#--------------------------------------------------------- GUI ---------------------------------------------------------

# Aliases
$window = $ window
$freqCanvas = $ "#frequency"
ctx = $freqCanvas[0].getContext "2d"
$mute = $ "#mute"

# Warp the shown frequency scale so the scale feels more natural to the human ear.
#
# warpFreq :: number -> number
warpFreq = (f) -> (Math.log f) / Math.LN2

# Inverse function of `warpFreq`
#
# unwarpFreq :: number -> number
unwarpFreq = (f) -> Math.pow 2, f

# Warped hearing range.
#
# warpFrequencyRange :: [number]
warpHearingRange = hearingRange.map warpFreq

# Converts a frequency [Hz] to a number 0…1 in a normalized warped hearing range scale.
# Can e.g. multiplied with a pixel width to get the x axis value.
#
# freqToNorm :: number -> number(0…1)
freqToNorm = (f) -> ((warpFreq f) - warpHearingRange[0]) / (warpHearingRange[1] - warpHearingRange[0])

# Inverse function of `freqToNorm`.
#
# freqFromNorm :: number(0…1) -> number
freqFromNorm = (n) -> unwarpFreq n * (warpHearingRange[1] - warpHearingRange[0]) + warpHearingRange[0]

# Critical bands converted to normalized warped scale.
#
# normedBandFreq :: [number(0…1)]
normedBandFreq = bandFreq.map freqToNorm

# The size of the browser window.
#
# windowSize :: Property { width: number, height: number }
windowSize = do ->
  getWindowSize = ->
    height: $window.height()
    width: $window.width()
  (($window.asEventStream "resize").map getWindowSize).toProperty getWindowSize()

# The size of the canvas.
#
# canvasSize :: Property { width: number, height: number }
canvasSize = windowSize.map (size) ->
  width: size.width
  height: Math.floor size.height * 80 / 100 # height : 80%

# Assure canvas is always the correct size.
canvasSize.assign $freqCanvas, "prop"
canvasSize.assign $freqCanvas, "css"

# negate :: boolean -> boolean
negate = (b) -> !b

# isPlaying :: Property boolean
isPlaying = ($mute.asEventStream "click").scan true, negate

# playButtonText :: Property string
playButtonText = isPlaying.map (playing) -> if playing then "Mute" else "Play"

# Update Play/Mute Button text
playButtonText.assign $mute, "text"


# Mousedown event stream on canvas
#
# mouseDown :: EventStream Event
mouseDown = $freqCanvas.asEventStream "mousedown"

# Mouseup event stream on window
#
# mouseUp :: EventStream Event
mouseUp = $window.asEventStream "mouseup"

# Extract (mouse) position from a jQuery event.
#
# extractPos :: Event -> { x: number, y: number }
extractPos = (event) ->
  x: event.pageX
  y: event.pageY

# Gives the mouse position if it is dragged over the canvas.
#
# mouseDrag :: Property { x: number, y: number }
mouseDrag = mouseDown.flatMap (event) ->
  ((($window.asEventStream "mousemove").toProperty event).takeUntil mouseUp).map extractPos

# The frequency set by mouse dragging over the canvas.
#
# frequency :: Property number
frequency = (canvasSize.sampledBy mouseDrag, (size, pos) ->
  freqFromNorm pos.x / size.width
).skipDuplicates().toProperty 440

# freq2 :: number
freq2 = 880

# freq12friction :: EventStream number(0…1)
freq12friction = (frequency.map (f) -> friction f, freq2).skipDuplicates()

# Draw on canvas
Bacon.onValues frequency, canvasSize, (f, size) ->
  f0 = 0
  (normedBandFreq.concat 1).forEach (wf, i) ->
    ctx.fillStyle = if i % 2 == 0 then "#C0C0C0" else "#FFFFFF"
    f1 = Math.round wf * size.width
    ctx.fillRect f0, 0, f1 - f0, size.height
    f0 = f1
  ctx.fillStyle = "blue"
  ctx.fillRect (Math.round (freqToNorm f) * size.width), 0, 1, size.height

#-------------------------------------------------------- Sound --------------------------------------------------------

if not AudioContext? # Web Audio API is available.
  console.log "no audio context available"
  return

context = new AudioContext()

oscillator = context.createOscillator()
frequency.onValue (value) -> oscillator.frequency.value = value
oscillator.connect context.destination

oscillator2 = context.createOscillator()
oscillator2.frequency.value = freq2
oscillator2.connect context.destination

oscillator.start 0
oscillator2.start 0
